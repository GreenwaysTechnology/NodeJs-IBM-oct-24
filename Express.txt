....................................................................................
			  Express.js - Web /Api Framework For node.js
.....................................................................................


What is express?
Express Fast, unopinionated, minimalist web framework for Node.js
express is built on top of http core module.


What apps can be built using express?


1.RESTFull WebServices

2.Dynamic content generation apps -  spring mvc, .netmvc.   with ui


Core features of Express:

1.Abstraction on core http module
2.lot of apis to send data like json api
3.routers : to create HTTP based web services and apps quickly.
4.middlewares : to extend core framework like - logging,database,security,templates...

Types of distributed Apps:

1.Monolithic App
2.Microservices

Express can be used to build Microservices?

 No,
Express is just monolithic App framework
.....................................................................................
		Express Key concepts: in express every thing object

Objects in express

1.Application
  We call Container object which containe other objects
  entry and exit of an application
  application is created by calling function

2.Request

3.Response

4.Router


1.Application object roll:

-Routing HTTP requests
-Configuring middleware
-Rendering HTML views
-Registering a template engine

Express Project setup:

1.You can install express dependencies in existing plain node project

2.You can use express cli , to create project structures

Steps:

1.create project folder
2.create src folder
3.npm init
4.install express dependency
5.start writing code

mkdir express-app
cd express-app
npm init
...........................

Installing express framework:
.............................

npm i express --save
npm i nodemon --save-dev

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon src/app.js"
  },
.....................................................................................
				Express- Coding
.....................................................................................

Express : HelloWorld

File Name : app.js - conventional name but you can save index.js as well.

//import express function
const express = require('express')
// console.log(express)

//creating application object
const app = express()

// console.log(app)

//api:
app.get('/hello', (req, res) => {
    //send response
    res.end('Hello Express')
})


//start the server

app.listen(3000, () => {
    console.log('Express Server is Ready!')
})
.................................................................................
.................................................................................
			HTTP verbs and CURD
....................................................................................

HTTP Verbs         Operation Type

GET                Read

POST               Write

PUT                Update

DELETE             Remove

URL Pattern:
///////////
Every Http Verbs are mapped against url

/api/customers        -GET ,POST,PUT,DELETE
/api/products
/api/reviews
 
CURD:
const express = require('express')
const app = express()

app.get('/api/customers', (req, res) => {
    res.end('customers -get')
})
app.post('/api/customers', (req, res) => {
    res.end('customers -post')
})
app.put('/api/customers', (req, res) => {
    res.end('customers -put')
})
app.delete('/api/customers', (req, res) => {
    res.end('customers -delete')
})
app.listen(3000, () => {
    console.log('Express Server is Ready!')
})
...................................................................................
			PORT,getting Server Info
...................................................................................

const express = require('express')
const app = express()

const PORT = 3000

app.get('/api/customers', (req, res) => {
    res.end('customers -get')
})
app.post('/api/customers', (req, res) => {
    res.end('customers -post')
})
app.put('/api/customers', (req, res) => {
    res.end('customers -put')
})
app.delete('/api/customers', (req, res) => {
    res.end('customers -delete')
})
const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
.....................................................................................
.....................................................................................
			Modularity,Async,JSON Payload
....................................................................................

src/services/customer.service.js

const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
}
module.exports = new CustomerService()

src/app.js
const express = require('express')
const app = express()
const customerServicce = require('./services/customer.service')

const PORT = 3000

app.get('/api/customers', async (req, res) => {
    try {
        const customers = await customerServicce.findAll()
        res.status(200).json(customers)
    }
    catch (err) {
        res.status(500).json(err)
    }
})
const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})

...................................................................................
			Externalized configuration
...................................................................................

We are going to use ".env" file.


We are going to use ".env" file.

Step : 1 Create file under root project dir
project
 |
 .env

Step 2: install dotenv dependency

npm install dotenv --save

Step 3: grab env variables

const express = require('express')
const { findAll } = require('./services/user.service')
require('dotenv').config()

const app = express()

//console.log(process.env.PORT)

const PORT = process.env.PORT || 3000

app.get('/', (req, res) => {
    res.end('Home Page')
})
app.get('/api/users', async (req, res) => {
    try {
        const users = await findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

Task
.....
Multi Enviroment configuration: explore how to configure for different environments
like production,dev,staging,testing
https://www.npmjs.com/package/dotenv
.....................................................................................
...................................................................................
....................................................................................
			Resources
....................................................................................

YourApp
  |
  routers - controllers
    |
    products
    customers
    payments
 |
  services
    products
    customers
    payments
 |
  repository
    products
    customers
 |
  
 app.js
..................................................................................... 
....................................................................................
			Resources
....................................................................................

YourApp
  |
  routers - controllers
    |
    products
    customers
    payments
 |
  services
    products
    customers
    payments
 |
  repository
    products
    customers
 |
  
 app.js
..................................................................................... Router:
  It is object used to isloate apis into separate folders and files


eg:

src/services/customer.service.js

const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
    async save() {
        return "save"
    }
}
module.exports = new CustomerService()

src/services/product.service.js

const PRODUCTS = [{
    id: 1,
    name: 'phone'
}]

class ProductService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, PRODUCTS)
        })
    }
    async save() {
        return "save"
    }
}
module.exports = new ProductService()
...............

Router:

src/routers/product.router.js
const express = require('express')
const productService = require('../services/product.service')
//create Router Object
const productRouter = express.Router()

productRouter.get('/', async (req, res) => {
    try {
        const products = await productService.findAll();
        res.json(products)
    }
    catch (err) {
        res.json({ err: err })
    }
})

productRouter.post('/', async (req, res) => {
    try {
        const product = await productService.save();
        res.json({ product })
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = productRouter

src/routers/customer.router.js
const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter

src/app.js
const express = require('express')
// const customerRouter = require('./routers/customer.router')
require('dotenv').config()
const app = express()

//Configure the router with application object
// app.use('/api/customers', customerRouter)
app.use('/api/customers', require('./routers/customer.router'))
app.use('/api/products', require('./routers/products.router'))

const PORT = process.env.PORT || 3000


const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
.....................................................................................
.....................................................................................
			  Dynamic Parameters : PATH PARAM
.....................................................................................

eg:

 GET /api/customers/1 
 GET /api/customers/2 

How to read paramter

router | app.get('/:id',(req,res)=>{
  const id = req.params.id
})

eg:


const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
    findById(id) {
        return CUSTOMERS.find(customer => customer.id === id)
    }
    async save() {
        return "save"
    }
}
module.exports = new CustomerService()


Router:
const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const customer = await customerServicce.findById(id);
        if (customer) {
            return res.json(customer)
        }
        return res.status(500).json({ err: `Requestd Customer ${id} Not Found` })

    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter

Testing:
GET localhost:3000/api/customers/1

{
    "id": 1,
    "name": "Subramanian",
    "location": "Coimbatore"
}

GET localhost:3000/api/customers/2

{
    "err": "Requestd Customer 2 Not Found"
}
....................................................................................
			Dynamic Parameters : Query Parameters

URL Pattern:
localhost:3000/api/customers/filter?city=chennai&state=TN

customerRouter.get('/filter', async (req, res) => {
    try {
        const params = req.query
        console.log(params)
        return res.status(200).json({ message: params })
    }
    catch (err) {
        return res.status(500).json({ err })
    }
})


output:
Express Web Server is running at 3000
{ city: 'chennai' }
{ city: 'chennai', state: 'TN' }

or 
customerRouter.get('/filter', async (req, res) => {
    try {
        // const params = req.query
        // console.log(params)
        // return res.status(200).json({ message: params })
        const { city, state } = req.query
        return res.status(200).json({ city, state })
    }
    catch (err) {
        return res.status(500).json({ err })
    }
})
....................................................................................
			Payload
...................................................................................

Service
const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
    async findById(id) {
        return CUSTOMERS.find(customer => customer.id === id)
    }
    async save(customer) {
        return CUSTOMERS.concat(customer)
    }
}
module.exports = new CustomerService()


Router
const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const customer = await customerServicce.findById(id);
        if (customer) {
            return res.json(customer)
        }
        return res.status(500).json({ err: `Requestd Customer ${id} Not Found` })

    }
    catch (err) {
        res.json({ err: err })
    }
})
customerRouter.post('/', (req, res) => {
    try {
        let customer = ''
        req.on('data', (chunk) => {
            customer += chunk
        })
        req.on('end', async () => {
            const customerObj = JSON.parse(customer)
            const users = await customerServicce.save(customerObj)
            return res.status(201).json(users)
        })
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter
...................................................................................
...................................................................................
			  Express middlewares
...................................................................................

Middlewares:

 What is Middleware?
 
 Middleware is javascript function that have access request object and response and next function in the application request response cycle.
  
 The difference between normal function which handles req and response with express , express takes thrird arg

 normal function
  app.get('url',(req,res)=>{})

 Middleware function
  app.get('url',(req,res,next)=>{
       //pre and post processing
  })
 req and res are objects
 next is a function

The "next" function is a function in the express router which,when invoked,executes the middleware succeeding the current middleware.

Tasks are middleware is doing:

1.Execute any code
2.Make changes to request and response object before handling real req and res cycle.
3.Middlwares can be attached on application object and also router object


use Method
  use method is used to registry middleware.

app.use
router.use

app.use('/api/users', require('./routers/users/user.router'))
 In this code we have registred already middleware which is called as "routerMidleware" - Router itself is middleware.

How to write our own middleware? - Custom Middleware.

Use Case : Middleware for GET /hello

const express = require('express')
require('dotenv').config()

const app = express()
const PORT = process.env.PORT || 3000

//middleware 
//req is object
//res is object
//next is function
app.get('/hello', (req, res, next) => {
    //middleware logic
    console.log('middleware is called')
    //move to next middleware in the chain or to request handler
    next()
})
app.get('/hello', (req, res) => {
    return res.end('hello')
})


const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
				
Sending custom headers
........................
const express = require('express')
const app = express()
require('dotenv').config()

const PORT = process.env.PORT || 3000

//middleware
app.get('/hello', (req, res, next) => {
    //middleware code
    console.log('middleware is called')
    res.set({ 'secret': '222232ssfsfsdf' })
    next() //this is required
})

//route
app.get('/hello', (req, res) => {
    res.end('hello')
})
//start server
const server = app.listen(PORT, () => {
    console.log(`Express Web Server is running at ${server.address().port}`)
})

The above middleware is called only for '/hello' router.
.....................................................................................
			 Global Middleware
.....................................................................................
I want to execute middleware for all route and all http methods in application.

const express = require('express')
const app = express()
require('dotenv').config()

const PORT = process.env.PORT || 3000

//middleware
app.use((req, res, next) => {
    //middleware code
    console.log('middleware is called')
    res.set({ 'secret': '222232ssfsfsdf' })
    next() //this is required
})

//route
app.get('/hello', (req, res) => {
    res.end('hello')
})

app.get('/hai', (req, res) => {
    res.end('hai')
})
//start server
const server = app.listen(PORT, () => {
    console.log(`Express Web Server is running at ${server.address().port}`)
})

....................................................................................
		Specific Url , any http method
....................................................................................

const express = require('express')
const app = express()
require('dotenv').config()

const PORT = process.env.PORT || 3000

//middleware
app.post('/hello',(req, res, next) => {
    res.set({ 'secret': '222232ssfsfsdf' })
    next() //this is required
})

//route
app.get('/hello', (req, res) => {
    res.end('hello get')
})

app.post('/hello', (req, res) => {
    res.end('hello post')
})
//start server
const server = app.listen(PORT, () => {
    console.log(`Express Web Server is running at ${server.address().port}`)
})
.....................................................................................
			Multi middlewares /Middleware chain
.....................................................................................

We can have n-number of middlewares,order of execution how we have registered.

const express = require('express')
const app = express()
require('dotenv').config()

const PORT = process.env.PORT || 3000

app.use((req, res, next) => {
    res.set('companyName', 'IBM')
    next()
})

//middleware
app.post('/hello', (req, res, next) => {
    res.set({ 'secret': '222232ssfsfsdf' })
    next() //this is required
})

//route
app.get('/hello', (req, res) => {
    res.end('hello get')
})
app.get('/hai', (req, res) => {
    res.end('hai get')
})
app.post('/hello', (req, res) => {
    res.end('hello post')
})
//start server
const server = app.listen(PORT, () => {
    console.log(`Express Web Server is running at ${server.address().port}`)
})
.....................................................................................
....................................................................................
			Router level middleware
....................................................................................

Middleware is set on Router Object

router.use((req,res,next)=>{
  next()
})
router.use('/url'(req,res,next)=>{
  next()
})
router.get('/url'(req,res,next)=>{
  next()
})

....................................................................................
			Router level middleware
....................................................................................

Middleware is set on Router Object

router.use((req,res,next)=>{
  next()
})
router.use('/url'(req,res,next)=>{
  next()
})
router.get('/url'(req,res,next)=>{
  next()
})

const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

customerRouter.use((req, res, next) => {
    console.log('customerRouter is called')
    next()
})

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const customer = await customerServicce.findById(id);
        if (customer) {
            return res.json(customer)
        }
        return res.status(500).json({ err: `Requestd Customer ${id} Not Found` })

    }
    catch (err) {
        res.json({ err: err })
    }
})
customerRouter.post('/', (req, res) => {
    try {
        let customer = ''
        req.on('data', (chunk) => {
            customer += chunk
        })
        req.on('end', async () => {
            const customerObj = JSON.parse(customer)
            const users = await customerServicce.save(customerObj)
            return res.status(201).json(users)
        })
    }
    catch (err) {
        res.json({ err: err })
    }
})


customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter
.....................................................................................
.....................................................................................
		  Can we pass parameters to the Middleware so that we can 
		     configure middleware - Configurable Middlewares
....................................................................................
Middleware which takes parameter , it should be higher order function. - function should return another function.

inner function is middleware.

Syntax: without explicit parameter

app.use(function(req,res,next)=>{})

Syntax: with explicit paramter

const mymiddleware = function(param) {

  return function(req,res,next){
     //access param

    next()
  }
}
app.use(mymiddleware('param'))


eg:

const myMiddleware = function (param) {
    //return function
    return function (req, res, next) {
        console.log('Got Param', param)
        next()
    }
}

app.use(myMiddleware('Marsh'))
.....................................................................................
.....................................................................................
				Types of Middlewares
.....................................................................................
1.Application middleware
2.Router level middlware
3.Error handling middleware
4.Third party middleware

1.Application middleware:
  Middleware is attached on application object

2.Router level middlware

->writing router:

 In express except ,request and response , all features including router is middleware.
 Router is in built middleware.

src/app.js
const express = require('express')
const customerRouter = require('./router/customer.router')
const app = express();

//register middleware 
app.use('/api/customers', customerRouter)

//api - based on resources - customer,products,payments


app.listen(3000, () => {
    console.log('Express server is running')
})

src/app/router/customer.router.js
const express = require('express')
const customerRouter = express.Router()

//middleware
customerRouter.use(function (req, res, next) {
    console.log('customer global middleware')
    next()
})
customerRouter.get('/', function (req, res, next) {
    console.log('customer get middleware')
    res.set({
        'customer': 'CUSTOMER GET'
    })
    next()
})

//api 
customerRouter.get('/', (req, res) => {
    res.json({ message: 'CUSTOMERS' })
})
customerRouter.post('/', (req, res) => {
    res.json({ message: 'customers post' })
})

module.exports = customerRouter

				Error Handling middleware
.....................................................................................

To handle error we have error handling middleware.


Error handling middleware takes four args instead of three arg.

app.use((err, req, res, next)=> {
    //handle error 
     console.err(err.message)
    //send error report to the user
    res.status(500).send('something went wrong')
})


const express = require('express')
const app = express();

app.use((err, req, res, next) => {
    //  next()
    res.status(500);
    res.send('Internal Server Error');
})

//api test error 
app.get('/api/greet/:message', (req, res) => {
    const message = req.params.message
    if (message === 'hello') {
        res.send(message)
    } else {
        throw new Error('Broken...')
    }
})

app.listen(3000, () => {
    console.log('Express server is running')
})
.....................................................................................
...................................................................................
			Built in and third party middlewares
...................................................................................
Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.
https://expressjs.com/en/resources/middleware.html

in order to parse the incoming payload into javascript object.

Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.


in order to parse the incoming payload into javascript object.

body-parser:

Node.js body parsing middleware.

Parse incoming request bodies in a middleware before your handlers, available under the req.body property.

Steps

1.install middleware
 npm install body-parser

2.require in the code
 const bodyParser = require('body-parser')

app.js
require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')

const PORT = process.env.PORT || 3000

//register bodyparserMiddleware
app.use(bodyParser.json())


app.use('/api/users', require('./routers/users/user.router'))


app.get('/', (req, res) => {
    res.end('Home Page')
})


//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

router/user.js
const express = require('express')
const { findAll, findById, save } = require('../../services/user.service')

//create Router
const UserRouter = express.Router()

//UserRouter middleware
UserRouter.use((req, res, next) => {
    console.log("User Router Globale Middleware")
    next()
})
UserRouter.post('/', (req, res, next) => {
    console.log("User Router Post Middleware")
    next()
})
//api
UserRouter.get('/', async (req, res) => {
    try {
        const users = await findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

UserRouter.get('/:id', async (req, res) => {
    const id = parseInt(req.params.id)
    try {
        const user = await findById(id);
        if (!user) {
            return res.json({ messgae: 'User Not Found' })
        }
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})

//here code receives input as plain string, not json standard string
// UserRouter.post('/', async (req, res) => {
//     try {
//         let data = ''
//         req.on('data', (chunk) => {
//             data += chunk
//         })
//         req.on('end', async () => {
//             const user = await save(data);
//             res.json(user)
//         })
//     }
//     catch (err) {
//         res.json({ err: err })
//     }
// })

UserRouter.post('/', async (req, res) => {
    try {
        const user = req.body
        console.log(user)
        const response = await save(user);
        res.json(response)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = UserRouter;

...................................................................................
			CORS - Cross Origin Resource sharing
....................................................................................

What is CORS?
 Internet browsers usually block access to unindefined websites from your services and apis.
 Implementing this module enable your server to share its resources solely with clients who reside in the same domain as yours.

 CORS an HTTP header based mechanism implemented by browsers, enables a server or api to specificy any origins

Implementation:
Step 1:
npm install cors

Step 2:
activate cors in app.js via middleware

const cors = require('cors')

app.use(cors()) - enabled for all routes

Enabled for particular route:

app.get('/products/:id', cors(), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for a Single Route'})
})

Note:
 HTTP methods,get,post,delete,update syntax
 
  app.get('url',requestlistener)

  app.get('url',middleware,requestlistener)
 
Default CORS Configuration values:
{
  "origin": "*",
  "methods": "GET,HEAD,PUT,PATCH,POST,DELETE",
  "preflightContinue": false,
  "optionsSuccessStatus": 204
}

Eg:
 In the options, you have to list out what are the urls,methods, are allowed

require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const fs = require('fs')
const morgan = require('morgan')
const path = require('path')
const cors = require('cors')

const corsOptions = {
    origin: 'http://www.abce.com'
}

const PORT = process.env.PORT || 3000

const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })

//enabled default cors
app.use(cors(corsOptions))

// app.use(cors())

app.use(bodyParser.json())
app.use(morgan('combined', { stream: accessLogStream }))

app.use(bodyParser.urlencoded({ extended: false }))

app.use('/api/users', require('./routers/users/user.router'))


app.get('/', (req, res) => {
    res.end('Home Page')
})


//cors api
// app.get('/api/customers/:id',(req, res, next) => {
//     res.json({ msg: 'cors enabled for only this particular' })
// })

app.get('/api/customers/:id', (req, res, next) => {
    res.json({ msg: 'cors enabled for only this particular' })
})

//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})


Testing:
create index.html
  run this file in vs code with "live server"

How to install live server?
  live server is extensions that should be installed first.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        async function getCustomer() {
            const res = await fetch('http://localhost:3001/api/customers/1')
            const result = await res.json()
            console.log(result)
        }
        getCustomer()
    </script>
</body>

</html>

right click on this file and try to run , from there you can send request.


In the browser console.
content_script_bundle.js:1 Attempting initialization Mon Jul 15 2024 20:48:41 GMT+0530 (India Standard Time)
index.html:1 Access to fetch at 'http://localhost:3001/api/customers/1' from origin 'http://127.0.0.1:5500' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value 'http://www.abce.com' that is not equal to the supplied origin. Have the server send the header with a valid value, or, if an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.Understand this error
index.html:13 

.....................................................................................
			  Database Integration
.....................................................................................

Express can integrate sql and no sql databases,provided database drivers.

sql databases:
1.microsoft sql server
2.MySql
3.Postgress SQL
4.Oracle
etc...

NoSql
1.Mongodb
2.redis
3.neo4j
etc...

.....................................................................................
			ORM and ODM
.....................................................................................

ORM - Object relational mapping for sql databases
ODM - Object Document Mapping for nosql-Mongodb

ORM framworks for node.js
1.Prisma
3.sequelize
2.typeorm
etc...

ODM framework for Mongodb:
.........................

1.mongoose -https://mongoosejs.com/docs/
2.Prisma 

.....................................................................................
				Mongodb - Mongoose
.....................................................................................

Here we are going to write code mongodb curd with mongoose framework.

Steps:

1.Make sure mongodb is installed or try to use mongodb cloud

2.create project 
G:\IBM\2024\Oct\NodeJs>mkdir expressMonogoose
G:\IBM\2024\Oct\NodeJs>cd expressMonogoose
G:\IBM\2024\Oct\NodeJs\expressMonogoose>

3.G:\IBM\2024\Oct\NodeJs\expressMonogoose>npm init --yes
Wrote to G:\IBM\2024\Oct\NodeJs\expressMonogoose\packa

4.install dependencies
npm i express
npm install mongoose --save
npm i nodemon --save-dev
npm i body-parser
npm i dotenv

Coding:

1.define schema
   plan for your collection
const mongoose = require('mongoose')

const schema = mongoose.schema({
    title:String,
    content:String
})
Datatypes:
1.String
2.Number
3.Date
4.Buffer
5.Boolean
6.Mixed
7.ObjectId
8.Array
9.Decimal128
10.Map
11.UUID

2.create model out of schema
const mongoose = require('mongoose')

const schema = mongoose.schema({
    title:String,
    content:String
})

module.exports=mongoose.model("Post",schema)

3.Connect mongodb.

require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const mongoose = require('mongoose')

const PORT = process.env.PORT || 3000


//connect to mongodb
async function connectDb() {
    try {
        await mongoose.connect(process.env.DATABASE_URL)
        console.log("Mongo is connected")

        const server = app.listen(PORT, () => {
            console.log(server.address())
            console.log(`Express is running @ ${server.address().port}`)
        })

    }
    catch (e) {
        console.log(e)
    }
}
connectDb()

app.get('/', (req, res) => {
    res.end('Home Page')
})

Here , we have started webserver only after mongodb is connected.


Full code:

src/services/posts.service.js
const Post = require('../models/Post.model')

class PostService {

    //curd operations

    async findAll() {
        return await Post.find()
    }
    async findById(id) {
        const post = await Post.findOne({ _id: id })
        return post
    }
    // async save(post) {
    //     const newPost = new Post({
    //         title: post.title,
    //         content: post.content
    //     })
    //     await newPost.save()
    //     return newPost
    // }
    async save({ title, content }) {
        // const newPost = new Post({
        //     title: title,
        //     content: content
        // })
        const newPost = new Post({
            title,
            content
        })
        await newPost.save()
        return newPost
    }
    async update(id, { title, content }) {
        const post = await Post.findOne({ _id: id })
        if (!post) {
            throw Error()
        }
        if (title) {
            post.title = title
        }
        if (content) {
            post.content = content
        }
        await post.save()
        return post
    }
    async remove(id) {
        const post = await Post.findOne({ _id: id })
        if (post) {
            await Post.deleteOne({ _id: id })
        } else {
            throw Error()
        }
    }
}
module.exports = new PostService();

src/routers/posts.router.js
const express = require('express')
const { findAll, findById, save, update, remove } = require('../services/post.service')

const PostRouter = express.Router()

PostRouter.get('/', async (req, res) => {
    try {
        const posts = await findAll()
        res.json(posts)
    }
    catch (err) {
        res.status(400).json({ err })
    }

})
PostRouter.post('/', async (req, res) => {
    const post = req.body
    try {
        const savedPost = await save(post)
        res.status(201).json(savedPost)
    }
    catch (err) {
        res.status(400).json({ err })
    }

})
PostRouter.get('/:id', async (req, res) => {
    const id = req.params.id
    try {
        const post = await findById(id)
        res.json(post)
    }
    catch (err) {
        res.status(404).json({ err: "Post does exits" })
    }

})
PostRouter.patch('/:id', async (req, res) => {
    const id = req.params.id
    const postInput = req.body
    try {
        const post = await update(id, postInput)
        res.json(post)
    }
    catch (err) {
        res.status(404).json({ err: "Post does exits" })
    }

})

PostRouter.delete('/:id', async (req, res) => {
    const id = req.params.id
    try {
        await remove(id)
        res.status(204).send()
    }
    catch (err) {
        res.status(404).json({ err: "Post does exits" })
    }

})


module.exports = PostRouter
app.js
require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const mongoose = require('mongoose')

const PORT = process.env.PORT || 3000

app.use(bodyParser.json())


//connect to mongodb
async function connectDb() {
    try {
        await mongoose.connect(process.env.DATABASE_URL)
        console.log("Mongo is connected")

        const server = app.listen(PORT, () => {
            console.log(server.address())
            console.log(`Express is running @ ${server.address().port}`)
        })

    }
    catch (e) {
        console.log(e)
    }
}
connectDb()

app.use("/api/posts", require("./routers/post.router"))

app.get('/', (req, res) => {
    res.end('Home Page')
})
.....................................................................................
Coding:

1.define schema
   plan for your collection
const mongoose = require('mongoose')

const schema = mongoose.schema({
    title:String,
    content:String
})
Datatypes:
1.String
2.Number
3.Date
4.Buffer
5.Boolean
6.Mixed
7.ObjectId
8.Array
9.Decimal128
10.Map
11.UUID

2.create model out of schema
const mongoose = require('mongoose')

const schema = mongoose.schema({
    title:String,
    content:String
})

module.exports=mongoose.model("Post",schema)

3.Connect mongodb.

require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const mongoose = require('mongoose')

const PORT = process.env.PORT || 3000


//connect to mongodb
async function connectDb() {
    try {
        await mongoose.connect(process.env.DATABASE_URL)
        console.log("Mongo is connected")

        const server = app.listen(PORT, () => {
            console.log(server.address())
            console.log(`Express is running @ ${server.address().port}`)
        })

    }
    catch (e) {
        console.log(e)
    }
}
connectDb()

app.get('/', (req, res) => {
    res.end('Home Page')
})

Here , we have started webserver only after mongodb is connected.


Full code:

src/services/posts.service.js
const Post = require('../models/Post.model')

class PostService {

    //curd operations

    async findAll() {
        return await Post.find()
    }
    async findById(id) {
        const post = await Post.findOne({ _id: id })
        return post
    }
    // async save(post) {
    //     const newPost = new Post({
    //         title: post.title,
    //         content: post.content
    //     })
    //     await newPost.save()
    //     return newPost
    // }
    async save({ title, content }) {
        // const newPost = new Post({
        //     title: title,
        //     content: content
        // })
        const newPost = new Post({
            title,
            content
        })
        await newPost.save()
        return newPost
    }
    async update(id, { title, content }) {
        const post = await Post.findOne({ _id: id })
        if (!post) {
            throw Error()
        }
        if (title) {
            post.title = title
        }
        if (content) {
            post.content = content
        }
        await post.save()
        return post
    }
    async remove(id) {
        const post = await Post.findOne({ _id: id })
        if (post) {
            await Post.deleteOne({ _id: id })
        } else {
            throw Error()
        }
    }
}
module.exports = new PostService();

src/routers/posts.router.js
const express = require('express')
const { findAll, findById, save, update, remove } = require('../services/post.service')

const PostRouter = express.Router()

PostRouter.get('/', async (req, res) => {
    try {
        const posts = await findAll()
        res.json(posts)
    }
    catch (err) {
        res.status(400).json({ err })
    }

})
PostRouter.post('/', async (req, res) => {
    const post = req.body
    try {
        const savedPost = await save(post)
        res.status(201).json(savedPost)
    }
    catch (err) {
        res.status(400).json({ err })
    }

})
PostRouter.get('/:id', async (req, res) => {
    const id = req.params.id
    try {
        const post = await findById(id)
        res.json(post)
    }
    catch (err) {
        res.status(404).json({ err: "Post does exits" })
    }

})
PostRouter.patch('/:id', async (req, res) => {
    const id = req.params.id
    const postInput = req.body
    try {
        const post = await update(id, postInput)
        res.json(post)
    }
    catch (err) {
        res.status(404).json({ err: "Post does exits" })
    }

})

PostRouter.delete('/:id', async (req, res) => {
    const id = req.params.id
    try {
        await remove(id)
        res.status(204).send()
    }
    catch (err) {
        res.status(404).json({ err: "Post does exits" })
    }

})


module.exports = PostRouter
app.js
require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const mongoose = require('mongoose')

const PORT = process.env.PORT || 3000

app.use(bodyParser.json())


//connect to mongodb
async function connectDb() {
    try {
        await mongoose.connect(process.env.DATABASE_URL)
        console.log("Mongo is connected")

        const server = app.listen(PORT, () => {
            console.log(server.address())
            console.log(`Express is running @ ${server.address().port}`)
        })

    }
    catch (e) {
        console.log(e)
    }
}
connectDb()

app.use("/api/posts", require("./routers/post.router"))

app.get('/', (req, res) => {
    res.end('Home Page')
})
.....................................................................................	
			Prisma,Mongo,Express
....................................................................................	

Mongo setup:
 1.We cant use local database without cluster configration for Prisma.
 2.we have to setup mongodb with cluster either locallly or mongo Atlas cloud platform.

Create Project and setup all libs:
..................................
mkdir prismaMongo
G:\IBM\2024\Oct\NodeJs\prismaMongo>npm init --yes


Dependencies:
1.express
2.body-parser
3.nodemon
4.prisma 
5.prisma client


npm i express
npm i body-parser
npm i nodemon --save-dev
npm install prisma
npm install @prisma/client


have basic setup in code

src/app.js
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const PORT = process.env.PORT || 3000

app.use(bodyParser.json())


const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})
................................................................................
			 setup prisma env
.................................................................................

prisma provides configuration files

npx prisma init

This command does two things:

1.creates a new directory called prisma that contains a file called schema.prisma,  which contains the Prisma schema with your database connection variable and schema  models

2.creates the .env file in the root directory of the project, which is used for defining environment variables (such as your database connection)


G:\IBM\2024\Oct\NodeJs\prismaMongo>npx prisma init

âœ” Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Set the provider of the datasource block in schema.prisma to match your database: postgresql, mysql, sqlite, sqlserver, mongodb or cockroachdb.
3. Run prisma db pull to turn your database schema into a Prisma schema.
4. Run prisma generate to generate the Prisma Client. You can then start querying your database.
5. Tip: Explore how you can extend the ORM with scalable connection pooling, global caching, and real-time database events. Read: https://pris.ly/cli/beyond-orm

More information in our documentation:
https://pris.ly/d/getting-started

In order to connect with mongodb we need to configure provider as mongodb

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}


.env
DATABASE_URL="mongodb+srv://subugee:subugee222@cluster0.shfpbhv.mongodb.net/myFirstDatabase?retryWrites=true&w=majority&appName=Cluster0"

coding:

Define Model:

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// Define model (schema)
model Post {
  id      String @id @default(auto()) @map("_id") @db.ObjectId
  title   String
  content String
}

src/app.js
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const PORT = process.env.PORT || 3000
const { PrismaClient } = require('@prisma/client')


app.use(bodyParser.json())

const prisma = new PrismaClient()

//for simplicity ; i am not creating routers,service layer; you can /should do when 
//write your app.

app.get('/api/posts', async(req, res) => {
    //read from mongo
    try {
        const posts = await prisma.post.findMany()
        res.json(posts)
    }
    catch (err) {
        console.log(err)
        res.json({ err })
    }
})
app.post('/api/posts', async (req, res) => {
    const input = req.body
    try {
        const post = await prisma.post.create({
            data: {
                title: input.title,
                content: input.content
            }
        })
        res.json(post)
    }
    catch (err) {
        console.log(err)
        res.json({ err })
    }
})


const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})
.....................................................................................
			SQL,Prisma Express
.....................................................................................


























